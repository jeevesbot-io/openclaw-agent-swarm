#!/bin/bash
# generate-prompt.sh - Smart prompt generator
# Usage: generate-prompt.sh <repo> <task-description> [options]

set -euo pipefail

# Configuration
SWARM_DIR="$HOME/.openclaw/swarm"
PROJECTS_DIR="$HOME/projects"
PROMPTS_DIR="$SWARM_DIR/prompts"
TEMPLATES_DIR="$SWARM_DIR/templates"
LIB_DIR="$SWARM_DIR/scripts/lib"
REGISTRY_FILE="$SWARM_DIR/repos.json"

# Source repo-context library
source "$LIB_DIR/repo-context.sh"

# Log
log() { echo "[$(date +%H:%M:%S)] $*" >&2; }

# Usage
usage() {
  cat >&2 << EOF
Usage: $0 <repo> <task-description> [options]

Arguments:
  repo              Repository name (must exist in ~/projects/)
  task-description  What to build/fix/improve

Options:
  --branch <name>   Branch name (default: auto-generated from task)
  --scope <scope>   backend|frontend|full (default: full)
  --type <type>     feature|bugfix|test|docs|refactor (default: feature)
  --output <path>   Output path (default: prompts/<branch>-<timestamp>.txt)

Examples:
  $0 sports-dashboard "Add API rate limiting middleware" --type feature --scope backend
  $0 MissionControls "Fix health endpoint timeout" --type bugfix
  $0 claude_jobhunt "Add pytest tests for parser" --type test

Output:
  Prints the path to the generated prompt file (suitable for piping to queue-task.sh)
EOF
  exit 1
}

# Parse arguments
if [ $# -lt 2 ]; then
  usage
fi

REPO="$1"
TASK_DESC="$2"
shift 2

# Defaults
BRANCH=""
SCOPE="full"
TYPE="feature"
OUTPUT_PATH=""

# Parse options
while [ $# -gt 0 ]; do
  case $1 in
    --branch)
      BRANCH="$2"
      shift 2
      ;;
    --scope)
      SCOPE="$2"
      shift 2
      ;;
    --type)
      TYPE="$2"
      shift 2
      ;;
    --output)
      OUTPUT_PATH="$2"
      shift 2
      ;;
    *)
      echo "ERROR: Unknown option: $1" >&2
      usage
      ;;
  esac
done

# Validate scope
if [[ ! "$SCOPE" =~ ^(backend|frontend|full)$ ]]; then
  echo "ERROR: Scope must be backend, frontend, or full" >&2
  exit 1
fi

# Validate type
if [[ ! "$TYPE" =~ ^(feature|bugfix|test|docs|refactor)$ ]]; then
  echo "ERROR: Type must be feature, bugfix, test, docs, or refactor" >&2
  exit 1
fi

# Validate repo exists
REPO_PATH="$PROJECTS_DIR/$REPO"
if [ ! -d "$REPO_PATH/.git" ]; then
  echo "ERROR: Repository not found: $REPO_PATH" >&2
  echo "Available repos in $PROJECTS_DIR:" >&2
  ls -1 "$PROJECTS_DIR" | grep -v '\..*' | head -10 >&2
  exit 1
fi

log "Generating prompt for $REPO..."

# Auto-generate branch name if not provided
if [ -z "$BRANCH" ]; then
  # Convert task description to branch suffix
  BRANCH_SUFFIX=$(echo "$TASK_DESC" | tr '[:upper:]' '[:lower:]' | tr -s ' ' '-' | sed 's/[^a-z0-9-]//g' | cut -c1-40)
  BRANCH="agent/${TYPE}-${BRANCH_SUFFIX}"
  log "Auto-generated branch: $BRANCH"
fi

# Ensure branch starts with agent/
if [[ ! "$BRANCH" =~ ^agent/ ]]; then
  echo "ERROR: Branch name must start with 'agent/'" >&2
  exit 1
fi

# Gather context
cd "$REPO_PATH"

log "Gathering project context..."

# Get repository metadata
DEFAULT_BRANCH=$(get_default_branch "$REPO_PATH")
OWNER=$(get_repo_owner "$REPO_PATH")
TECH_STACK=$(detect_tech_stack "$REPO_PATH")
CONVENTIONS=$(detect_conventions "$REPO_PATH")

# Get project docs
PROJECT_DOCS=$(get_project_docs "$REPO_PATH")

# Get repository structure
log "Analysing repository structure ($SCOPE)..."
REPO_STRUCTURE=$(get_structure "$REPO_PATH" "$SCOPE")

# Get recent changes
log "Checking recent changes..."
GIT_LOG=$(git log --oneline -10 2>/dev/null || echo "(No git history)")
GIT_DIFF_STAT=$(git diff --stat HEAD~5..HEAD 2>/dev/null || echo "(No recent changes)")

# Get Obsidian notes
OBSIDIAN_NOTES=$(get_obsidian_notes "$REPO")
if [ -n "$OBSIDIAN_NOTES" ]; then
  OBSIDIAN_NOTES="### Related Notes\n\n$OBSIDIAN_NOTES"
fi

# Check for environment requirements
ENV_NOTES=""
if [ -f ".env.example" ]; then
  ENV_NOTES="\n**Environment:** Check .env.example for required configuration\n"
fi

# Prepare commit message parts
case $TYPE in
  feature)
    COMMIT_PREFIX="feat"
    ;;
  bugfix)
    COMMIT_PREFIX="fix"
    ;;
  test)
    COMMIT_PREFIX="test"
    ;;
  docs)
    COMMIT_PREFIX="docs"
    ;;
  refactor)
    COMMIT_PREFIX="refactor"
    ;;
esac

COMMIT_SUMMARY=$(echo "$TASK_DESC" | cut -c1-60)
PR_BODY="This PR implements: $TASK_DESC\n\nGenerated by agent swarm."

# Load template
TEMPLATE_FILE="$TEMPLATES_DIR/task-prompt.txt"
if [ ! -f "$TEMPLATE_FILE" ]; then
  echo "ERROR: Template not found: $TEMPLATE_FILE" >&2
  exit 1
fi

PROMPT_CONTENT=$(cat "$TEMPLATE_FILE")

# Replace template variables
PROMPT_CONTENT="${PROMPT_CONTENT//\{\{TASK_DESCRIPTION\}\}/$TASK_DESC}"
PROMPT_CONTENT="${PROMPT_CONTENT//\{\{REPO\}\}/$REPO}"
PROMPT_CONTENT="${PROMPT_CONTENT//\{\{BRANCH\}\}/$BRANCH}"
PROMPT_CONTENT="${PROMPT_CONTENT//\{\{DEFAULT_BRANCH\}\}/$DEFAULT_BRANCH}"
PROMPT_CONTENT="${PROMPT_CONTENT//\{\{OWNER\}\}/$OWNER}"
PROMPT_CONTENT="${PROMPT_CONTENT//\{\{TECH_STACK\}\}/$TECH_STACK}"
PROMPT_CONTENT="${PROMPT_CONTENT//\{\{COMMIT_PREFIX\}\}/$COMMIT_PREFIX}"
PROMPT_CONTENT="${PROMPT_CONTENT//\{\{COMMIT_SUMMARY\}\}/$COMMIT_SUMMARY}"
PROMPT_CONTENT="${PROMPT_CONTENT//\{\{PR_BODY\}\}/$PR_BODY}"

# Multi-line replacements (preserve newlines)
PROMPT_CONTENT="${PROMPT_CONTENT//\{\{PROJECT_DOCS\}\}/$PROJECT_DOCS}"
PROMPT_CONTENT="${PROMPT_CONTENT//\{\{REPO_STRUCTURE\}\}/$REPO_STRUCTURE}"
PROMPT_CONTENT="${PROMPT_CONTENT//\{\{GIT_LOG\}\}/$GIT_LOG}"
PROMPT_CONTENT="${PROMPT_CONTENT//\{\{GIT_DIFF_STAT\}\}/$GIT_DIFF_STAT}"
PROMPT_CONTENT="${PROMPT_CONTENT//\{\{CONVENTIONS\}\}/$CONVENTIONS}"
PROMPT_CONTENT="${PROMPT_CONTENT//\{\{OBSIDIAN_NOTES\}\}/$OBSIDIAN_NOTES}"

# Task details (expanded with context)
TASK_DETAILS="$TASK_DESC"
if [ -n "$ENV_NOTES" ]; then
  TASK_DETAILS="$TASK_DETAILS\n$ENV_NOTES"
fi
PROMPT_CONTENT="${PROMPT_CONTENT//\{\{TASK_DETAILS\}\}/$TASK_DETAILS}"

# Determine output path
if [ -z "$OUTPUT_PATH" ]; then
  BRANCH_SUFFIX=$(echo "$BRANCH" | sed 's/^agent\///')
  TIMESTAMP=$(date +%s)
  OUTPUT_PATH="$PROMPTS_DIR/${BRANCH_SUFFIX}-${TIMESTAMP}.txt"
fi

# Ensure prompts directory exists
mkdir -p "$(dirname "$OUTPUT_PATH")"

# Write prompt
echo -e "$PROMPT_CONTENT" > "$OUTPUT_PATH"

PROMPT_SIZE=$(wc -c < "$OUTPUT_PATH")
log "âœ“ Prompt generated ($PROMPT_SIZE bytes)"
log "  Repository:  $REPO"
log "  Branch:      $BRANCH"
log "  Type:        $TYPE"
log "  Scope:       $SCOPE"
log "  Tech Stack:  $TECH_STACK"

# Output the path (this is what gets piped to queue-task.sh)
echo "$OUTPUT_PATH"

exit 0
